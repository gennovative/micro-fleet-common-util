{"version":3,"sources":["app/DependencyContainer.ts"],"names":[],"mappings":";;AAAA,0BAA0B;AAC1B,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,CAAC,gBAAgB,CAAC,KAAK,UAAU,EAAE;IAChE,OAAO,CAAC,kBAAkB,CAAC,CAAC;CAC5B;AAED,yCAA2F;AAoBlF,qBApBA,sBAAU,CAoBA;AAAE,iBApBA,kBAAM,CAoBA;AAAE,mBApBA,oBAAQ,CAoBA;AAAE,oBApBuB,qBAAS,CAoBvB;AAnBhD,mCAAgC;AAGhC;IAEC,YAAoB,QAA6C;QAA7C,aAAQ,GAAR,QAAQ,CAAqC;IAEjE,CAAC;IAED,WAAW;QACV,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,CAAC;IAClC,CAAC;IAED,WAAW;QACV,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,CAAC;IAClC,CAAC;CACD;AAbD,oCAaC;AAgDD;IAGC;QACC,IAAI,CAAC,UAAU,GAAG,IAAI,qBAAS,EAAE,CAAC;IACnC,CAAC;IAGD;;OAEG;IACI,IAAI,CAAa,UAA2B,EAAE,WAAiC;QACrF,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,aAAK,CAAC,gBAAgB,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;QAEnD,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,EAC9B,OAAO,EAAE,KAAK,CAAC;QAEhB,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;QAEpC,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAa,UAAU,CAAC,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC;QACvE,KAAK,GAAG,IAAI,YAAY,CAAa,OAAO,CAAC,CAAC;QAE9C,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;OAEG;IACI,YAAY,CAAI,UAA2B,EAAE,KAAQ;QAC3D,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;QACpC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAI,UAAU,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IAC5D,CAAC;IAED;;OAEG;IACI,OAAO;QACb,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC;QAC5B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,UAA2B;QACzC,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACI,OAAO,CAAI,UAA2B;QAC5C,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,IAAI;YACH,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAI,UAAU,CAAC,CAAC;SAC1C;QAAC,OAAO,EAAE,EAAE;YACZ,OAAO,CAAC,GAAG,CAAC,iBAAiB,GAAG,EAAE,CAAC,CAAC;YACpC,OAAO,IAAI,CAAC;SACZ;IACF,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,UAA2B;QACxC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IACpC,CAAC;IAGO,iBAAiB;QACxB,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACrB,MAAM,8BAA8B,CAAC;SACrC;IACF,CAAC;IAEO,kBAAkB,CAAC,UAA2B;QACrD,IAAI,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YACxC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;SACnC;IACF,CAAC;CACD;AAjFD,kDAiFC","file":"DependencyContainer.js","sourcesContent":["/* istanbul ignore else */\r\nif (!Reflect || typeof Reflect['hasOwnMetadata'] !== 'function') {\r\n\trequire('reflect-metadata');\r\n}\r\n\r\nimport { injectable, inject, decorate, Container, interfaces, unmanaged } from 'inversify';\r\nimport { Guard } from './Guard';\r\n\r\n\r\nexport class BindingScope<T> {\r\n\t\r\n\tconstructor(private _binding: interfaces.BindingInWhenOnSyntax<T>) {\r\n\t\t\r\n\t}\r\n\r\n\tasSingleton(): void {\r\n\t\tthis._binding.inSingletonScope();\r\n\t}\r\n\r\n\tasTransient(): void {\r\n\t\tthis._binding.inTransientScope();\r\n\t}\r\n}\r\n\r\n\r\nexport { injectable, inject, decorate, unmanaged };\r\n\r\nexport interface INewable<T> extends interfaces.Newable<T> { }\r\n\r\nexport interface IDependencyContainer { \r\n\t/**\r\n\t * Registers `constructor` as resolvable with key `identifier`.\r\n\t * @param {string | symbol} identifier - The key used to resolve this dependency.\r\n\t * @param {INewable<T>} constructor - A class that will be resolved with `identifier`.\r\n\t * \r\n\t * @return {BindingScope} - A BindingScope instance that allows settings dependency as singleton or transient.\r\n\t */\r\n\tbind<TInterface>(identifier: string | symbol, constructor: INewable<TInterface>): BindingScope<TInterface>;\r\n\t\r\n\t/**\r\n\t * Registers a constant value with key `identifier`.\r\n\t * @param {string | symbol} identifier - The key used to resolve this dependency.\r\n\t * @param {T} value - The constant value to store.\r\n\t */\r\n\tbindConstant<T>(identifier: string | symbol, value: T);\r\n\r\n\t/**\r\n\t * Gets rid of all registered dependencies.\r\n\t */\r\n\tdispose(): void;\r\n\r\n\t/**\r\n\t * Checks if an identifier is bound with any dependency.\r\n\t */\r\n\tisBound(identifier: string | symbol): boolean;\r\n\r\n\t/**\r\n\t * Retrieves an instance of dependency with all its own dependencies resolved.\r\n\t * @param {string | Symbol} - The key that was used to register before.\r\n\t * \r\n\t * @return {T} - An instance of registered type, or null if that type was not registered.\r\n\t */\r\n\tresolve<T>(identifier: string | symbol): T;\r\n\r\n\t/**\r\n\t * Gets rid of the dependency related to this identifier.\r\n\t */\r\n\tunbind(identifier: string | symbol): void;\r\n}\r\n\r\nexport class DependencyContainer {\r\n\tprivate _container: Container;\r\n\r\n\tconstructor() {\r\n\t\tthis._container = new Container();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.bind \r\n\t */\r\n\tpublic bind<TInterface>(identifier: string | symbol, constructor: INewable<TInterface>): BindingScope<TInterface> {\r\n\t\tthis.assertNotDisposed();\r\n\t\tGuard.assertArgDefined('constructor', constructor);\r\n\r\n\t\tlet container = this._container,\r\n\t\t\tbinding, scope;\r\n\t\t\r\n\t\tthis.unboundIfDuplicate(identifier);\r\n\r\n\t\tbinding = this._container.bind<TInterface>(identifier).to(constructor);\r\n\t\tscope = new BindingScope<TInterface>(binding);\r\n\r\n\t\treturn scope;\r\n\t}\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.bindConstant \r\n\t */\r\n\tpublic bindConstant<T>(identifier: string | symbol, value: T): void {\r\n\t\tthis.unboundIfDuplicate(identifier);\r\n\t\tthis._container.bind<T>(identifier).toConstantValue(value);\r\n\t}\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.dispose \r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tthis._container.unbindAll();\r\n\t\tthis._container = null;\r\n\t}\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.isBound \r\n\t */\r\n\tpublic isBound(identifier: string | symbol): boolean {\r\n\t\treturn this._container.isBound(identifier);\r\n\t}\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.resolve \r\n\t */\r\n\tpublic resolve<T>(identifier: string | symbol): T {\r\n\t\tthis.assertNotDisposed();\r\n\t\ttry {\r\n\t\t\treturn this._container.get<T>(identifier);\r\n\t\t} catch (ex) {\r\n\t\t\tconsole.log('Resolve Error: ' + ex);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @see IDependencyContainer.unbind \r\n\t */\r\n\tpublic unbind(identifier: string | symbol): void {\r\n\t\tthis._container.unbind(identifier);\r\n\t}\r\n\r\n\r\n\tprivate assertNotDisposed() {\r\n\t\tif (!this._container) {\r\n\t\t\tthrow 'Container has been disposed!';\r\n\t\t}\r\n\t}\r\n\r\n\tprivate unboundIfDuplicate(identifier: string | symbol): void {\r\n\t\tif (this._container.isBound(identifier)) {\r\n\t\t\tthis._container.unbind(identifier);\r\n\t\t}\r\n\t}\r\n}"]}